---
name: todo-list-6
epic: todo-list
type: task
status: ready
priority: high
parallel: true
dependencies: [2]
assignee: []
effort: 8
tags: [javascript, architecture, mvc, event-driven, application-logic]
created: 2025-10-19T11:16:15Z
updated: 2025-10-19T11:33:47Z
---

# Task 6: Core JavaScript Architecture

## Overview
Implement the main JavaScript application architecture using event-driven design patterns, component-based structure, and MVC (Model-View-Controller) principles. This includes the main TodoApp class, UI rendering system, and event handling.

## Description
This task focuses on creating the core JavaScript architecture that drives the todo list application. The implementation uses modern ES6+ features, event-driven architecture, and component-based design to create a maintainable and scalable application structure. The architecture provides separation of concerns between data models, UI rendering, and user interactions.

## Technical Implementation

### 1. Main Application Class (TodoApp)

```javascript
/**
 * Main Todo List Application Controller
 *
 * @class TodoApp
 * @description Core application controller that orchestrates all functionality
 */
class TodoApp {
    constructor() {
        // Dependencies
        this.state = null;
        this.storage = null;
        this.validator = null;

        // DOM Elements
        this.elements = {};

        // Configuration
        this.config = {
            autoSave: true,
            autoSaveDelay: 1000, // 1 second
            maxUndoSteps: 50,
            animationDuration: 300,
            debounceTime: 300
        };

        // State Management
        this.isInitialized = false;
        this.isLoading = true;
        this.autoSaveTimer = null;
        this.undoStack = [];
        this.redoStack = [];

        // Event Listeners
        this.eventListeners = new Map();

        // Performance tracking
        this.performance = {
            renderTime: 0,
            lastOperation: null,
            operationCount: 0
        };
    }

    /**
     * Initialize the application
     * @returns {Promise<void>}
     */
    async init() {
        if (this.isInitialized) {
            console.warn('Application already initialized');
            return;
        }

        try {
            console.log('Initializing Todo App...');

            // Initialize dependencies
            await this.initializeDependencies();

            // Set up DOM elements
            this.setupDOMElements();

            // Set up event listeners
            this.setupEventListeners();

            // Load saved data
            await this.loadApplicationData();

            // Initial render
            this.render();

            // Update application state
            this.isInitialized = true;
            this.isLoading = false;

            // Emit initialization complete event
            this.emit('initialized');

            console.log('Todo App initialized successfully');
        } catch (error) {
            console.error('Failed to initialize application:', error);
            this.handleError(error);
        }
    }

    /**
     * Initialize application dependencies
     * @private
     */
    async initializeDependencies() {
        // Initialize state management
        this.state = new AppState();

        // Initialize storage service
        this.storage = new StorageService();

        // Initialize validation service
        this.validator = new ValidationService();
    }

    /**
     * Set up DOM element references
     * @private
     */
    setupDOMElements() {
        this.elements = {
            app: document.getElementById('app'),
            taskForm: document.getElementById('task-form'),
            taskInput: document.getElementById('task-input'),
            taskList: document.getElementById('task-list'),
            emptyState: document.getElementById('empty-state'),
            progressBar: document.getElementById('progress-bar'),
            progressFill: document.querySelector('.progress-fill'),
            completedCount: document.getElementById('completed-count'),
            totalCount: document.getElementById('total-count'),
            progressInfo: document.getElementById('progress-info'),
            footerText: document.querySelector('.footer-text')
        };

        // Validate DOM elements
        for (const [key, element] of Object.entries(this.elements)) {
            if (!element) {
                console.error(`DOM element not found: ${key}`);
                throw new Error(`Missing required DOM element: ${key}`);
            }
        }
    }

    /**
     * Set up event listeners
     * @private
     */
    setupEventListeners() {
        // Form submission
        this.elements.taskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleAddTask();
        });

        // Input events with debouncing
        this.elements.taskInput.addEventListener('input',
            this.debounce(() => this.handleInputChange(), this.config.debounceTime)
        );

        // Keyboard navigation
        document.addEventListener('keydown', (e) => this.handleKeyboardNavigation(e));

        // Storage events for cross-tab sync
        window.addEventListener('storage', (e) => this.handleStorageEvent(e));

        // Storage error events
        window.addEventListener('storageError', (e) => this.handleStorageError(e));

        // Window events
        window.addEventListener('beforeunload', () => this.handleBeforeUnload());
        window.addEventListener('online', () => this.handleOnlineStatus(true));
        window.addEventListener('offline', () => this.handleOnlineStatus(false));

        // Custom application events
        this.on('task:created', () => this.autoSave());
        this.on('task:updated', () => this.autoSave());
        this.on('task:deleted', () => this.autoSave());
        this.on('state:changed', () => this.render());
    }

    /**
     * Load application data from storage
     * @private
     */
    async loadApplicationData() {
        try {
            const savedState = await this.storage.loadState();
            this.state = savedState;
            console.log('Application data loaded successfully');
        } catch (error) {
            console.warn('Failed to load saved data, using defaults:', error);
            this.state = new AppState();
        }
    }
}
```

### 2. Task CRUD Operations

```javascript
/**
 * Task Management Methods
 *
 * These methods handle all task-related operations and state management
 */

class TodoApp {
    // ... previous constructor and setup methods ...

    /**
     * Add a new task
     * @param {string} text - Task text
     * @param {Object} options - Additional options (priority, category)
     * @returns {Promise<string>} Task ID or null if failed
     */
    async addTask(text, options = {}) {
        try {
            // Validate input
            if (!text || typeof text !== 'string') {
                throw new Error('Task text is required');
            }

            const taskData = { text, ...options };

            // Validate task data
            const validation = this.validator.validateTask(taskData);
            if (!validation.isValid) {
                this.emit('validation:error', { errors: validation.errors });
                return null;
            }

            // Sanitize input
            const sanitized = this.validator.sanitizeTask(taskData);

            // Create task instance
            const task = new Task(sanitized);

            // Add to state
            this.state.addTask(task);

            // Add to undo stack
            this.addToUndoStack({
                action: 'create',
                taskId: task.id,
                taskData: task.toJSON()
            });

            // Clear redo stack
            this.redoStack = [];

            // Emit events
            this.emit('task:created', { task: task.toJSON() });
            this.emit('state:changed');

            // Update performance tracking
            this.performance.lastOperation = 'create';
            this.performance.operationCount++;

            return task.id;
        } catch (error) {
            console.error('Failed to add task:', error);
            this.handleError(error);
            return null;
        }
    }

    /**
     * Toggle task completion status
     * @param {string} taskId - Task ID to toggle
     * @returns {Promise<boolean>} True if successful
     */
    async toggleTask(taskId) {
        try {
            const task = this.state.tasks.find(t => t.id === taskId);
            if (!task) {
                throw new Error(`Task not found: ${taskId}`);
            }

            // Store previous state for undo
            const previousState = task.toJSON();

            // Toggle completion
            const updated = this.state.updateTask(taskId, {
                completed: !task.completed
            });

            if (updated) {
                // Add to undo stack
                this.addToUndoStack({
                    action: 'toggle',
                    taskId,
                    previousState
                });

                // Clear redo stack
                this.redoStack = [];

                // Emit events
                this.emit('task:updated', {
                    taskId,
                    completed: !task.completed
                });
                this.emit('state:changed');

                // Update performance tracking
                this.performance.lastOperation = 'toggle';
                this.performance.operationCount++;

                return true;
            }

            return false;
        } catch (error) {
            console.error('Failed to toggle task:', error);
            this.handleError(error);
            return false;
        }
    }

    /**
     * Update task text
     * @param {string} taskId - Task ID to update
     * @param {string} newText - New task text
     * @returns {Promise<boolean>} True if successful
     */
    async updateTaskText(taskId, newText) {
        try {
            // Validate input
            if (!newText || typeof newText !== 'string') {
                throw new Error('Task text is required');
            }

            const task = this.state.tasks.find(t => t.id === taskId);
            if (!task) {
                throw new Error(`Task not found: ${taskId}`);
            }

            // Validate new text
            const validation = this.validator.validateTask({ text: newText });
            if (!validation.isValid) {
                this.emit('validation:error', { errors: validation.errors });
                return false;
            }

            // Store previous state for undo
            const previousState = task.toJSON();

            // Sanitize input
            const sanitizedText = this.validator.sanitizeText(newText);

            // Update task
            const updated = this.state.updateTask(taskId, {
                text: sanitizedText
            });

            if (updated) {
                // Add to undo stack
                this.addToUndoStack({
                    action: 'update',
                    taskId,
                    previousState
                });

                // Clear redo stack
                this.redoStack = [];

                // Emit events
                this.emit('task:updated', { taskId, text: sanitizedText });
                this.emit('state:changed');

                // Update performance tracking
                this.performance.lastOperation = 'update';
                this.performance.operationCount++;

                return true;
            }

            return false;
        } catch (error) {
            console.error('Failed to update task:', error);
            this.handleError(error);
            return false;
        }
    }

    /**
     * Delete a task
     * @param {string} taskId - Task ID to delete
     * @returns {Promise<boolean>} True if successful
     */
    async deleteTask(taskId) {
        try {
            const task = this.state.tasks.find(t => t.id === taskId);
            if (!task) {
                throw new Error(`Task not found: ${taskId}`);
            }

            // Store task data for undo
            const taskData = task.toJSON();

            // Remove from state
            const removed = this.state.removeTask(taskId);

            if (removed) {
                // Add to undo stack
                this.addToUndoStack({
                    action: 'delete',
                    taskId,
                    taskData
                });

                // Clear redo stack
                this.redoStack = [];

                // Emit events
                this.emit('task:deleted', { taskId, taskData });
                this.emit('state:changed');

                // Update performance tracking
                this.performance.lastOperation = 'delete';
                this.performance.operationCount++;

                return true;
            }

            return false;
        } catch (error) {
            console.error('Failed to delete task:', error);
            this.handleError(error);
            return false;
        }
    }

    /**
     * Reorder tasks
     * @param {string} taskId - Task ID to move
     * @param {number} newIndex - New position index
     * @returns {Promise<boolean>} True if successful
     */
    async reorderTasks(taskId, newIndex) {
        try {
            const task = this.state.tasks.find(t => t.id === taskId);
            if (!task) {
                throw new Error(`Task not found: ${taskId}`);
            }

            const oldIndex = task.order;
            if (oldIndex === newIndex) {
                return true; // No change needed
            }

            // Reorder tasks in array
            const tasks = [...this.state.tasks];
            tasks.splice(oldIndex, 1);
            tasks.splice(newIndex, 0, task);

            // Update task orders
            tasks.forEach((t, index) => {
                t.order = index;
            });

            // Update state
            this.state.tasks = tasks;
            this.state.updateStats();

            // Add to undo stack
            this.addToUndoStack({
                action: 'reorder',
                taskId,
                oldIndex,
                newIndex
            });

            // Clear redo stack
            this.redoStack = [];

            // Emit events
            this.emit('task:reordered', { taskId, oldIndex, newIndex });
            this.emit('state:changed');

            // Update performance tracking
            this.performance.lastOperation = 'reorder';
            this.performance.operationCount++;

            return true;
        } catch (error) {
            console.error('Failed to reorder tasks:', error);
            this.handleError(error);
            return false;
        }
    }
}
```

### 3. UI Rendering System

```javascript
/**
 * UI Rendering Methods
 *
 * These methods handle all DOM manipulation and UI updates
 */

class TodoApp {
    // ... previous methods ...

    /**
     * Render the entire application UI
     */
    render() {
        const startTime = performance.now();

        try {
            // Update progress bar
            this.renderProgressBar();

            // Update statistics
            this.renderStats();

            // Render task list
            this.renderTaskList();

            // Update empty state visibility
            this.renderEmptyState();

            // Update footer
            this.renderFooter();

            // Update performance tracking
            const endTime = performance.now();
            this.performance.renderTime = endTime - startTime;

            // Emit render complete event
            this.emit('render:complete', {
                renderTime: this.performance.renderTime,
                taskCount: this.state.tasks.length
            });
        } catch (error) {
            console.error('Render failed:', error);
            this.handleError(error);
        }
    }

    /**
     * Render progress bar and statistics
     * @private
     */
    renderProgressBar() {
        const completionRate = this.state.stats.completionRate;

        // Update progress bar fill
        if (this.elements.progressFill) {
            this.elements.progressFill.style.width = `${completionRate}%`;

            // Update ARIA attributes
            this.elements.progressBar.setAttribute('aria-valuenow', completionRate);
        }

        // Update progress info text
        if (this.elements.progressInfo) {
            const completed = this.state.stats.completed;
            const total = this.state.stats.total;
            this.elements.progressInfo.textContent =
                total > 0 ? `${completed} of ${total} completed` : 'No tasks';
        }
    }

    /**
     * Render statistics display
     * @private
     */
    renderStats() {
        if (this.elements.completedCount) {
            this.elements.completedCount.textContent = this.state.stats.completed;
        }

        if (this.elements.totalCount) {
            this.elements.totalCount.textContent = this.state.stats.total;
        }
    }

    /**
     * Render task list
     * @private
     */
    renderTaskList() {
        const container = this.elements.taskList;
        const tasks = this.state.getFilteredTasks();

        // Clear current list
        container.innerHTML = '';

        // Sort tasks by order
        const sortedTasks = [...tasks].sort((a, b) => a.order - b.order);

        // Render each task
        sortedTasks.forEach(task => {
            const taskElement = this.createTaskElement(task);
            container.appendChild(taskElement);
        });
    }

    /**
     * Create individual task element
     * @param {Task} task - Task object
     * @returns {HTMLElement} Task list element
     * @private
     */
    createTaskElement(task) {
        const li = document.createElement('li');
        li.className = `task-item ${task.completed ? 'completed' : ''}`;
        li.dataset.taskId = task.id;
        li.setAttribute('role', 'listitem');

        // Checkbox
        const checkbox = document.createElement('div');
        checkbox.className = `task-checkbox ${task.completed ? 'checked' : ''}`;
        checkbox.setAttribute('role', 'checkbox');
        checkbox.setAttribute('aria-checked', task.completed);
        checkbox.tabIndex = 0;

        // Task text
        const textSpan = document.createElement('span');
        textSpan.className = 'task-text';
        textSpan.textContent = task.text;
        textSpan.setAttribute('role', 'textbox');
        textSpan.setAttribute('contenteditable', 'false');

        // Edit input (hidden by default)
        const editInput = document.createElement('input');
        editInput.type = 'text';
        editInput.className = 'task-edit-input';
        editInput.value = task.text;
        editInput.style.display = 'none';

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'task-delete-btn';
        deleteBtn.textContent = 'Delete';
        deleteBtn.setAttribute('aria-label', `Delete task: ${task.text}`);

        // Add event listeners
        checkbox.addEventListener('click', () => this.toggleTask(task.id));
        checkbox.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                this.toggleTask(task.id);
            }
        });

        textSpan.addEventListener('dblclick', () => this.startEditTask(task.id));
        editInput.addEventListener('blur', () => this.finishEditTask(task.id));
        editInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.finishEditTask(task.id);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.cancelEditTask(task.id);
            }
        });

        deleteBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to delete this task?')) {
                this.deleteTask(task.id);
            }
        });

        // Assemble task element
        li.appendChild(checkbox);
        li.appendChild(textSpan);
        li.appendChild(editInput);
        li.appendChild(deleteBtn);

        return li;
    }

    /**
     * Update empty state visibility
     * @private
     */
    renderEmptyState() {
        const hasTasks = this.state.tasks.length > 0;

        if (this.elements.emptyState) {
            this.elements.emptyState.style.display = hasTasks ? 'none' : 'block';
        }

        if (this.elements.taskList) {
            this.elements.taskList.style.display = hasTasks ? 'block' : 'none';
        }
    }

    /**
     * Update footer information
     * @private
     */
    renderFooter() {
        if (this.elements.footerText) {
            const taskCount = this.elements.footerText.querySelector('.task-count');
            if (taskCount) {
                const count = this.state.tasks.length;
                taskCount.textContent = `${count} ${count === 1 ? 'task' : 'tasks'}`;
            }
        }
    }
}
```

### 4. Event System & Helper Methods

```javascript
/**
 * Event System and Utility Methods
 *
 * These methods provide the application event system and helper utilities
 */

class TodoApp {
    // ... previous methods ...

    /**
     * Event handling system
     */

    /**
     * Add event listener
     * @param {string} eventName - Event name
     * @param {Function} callback - Event callback
     */
    on(eventName, callback) {
        if (!this.eventListeners.has(eventName)) {
            this.eventListeners.set(eventName, new Set());
        }
        this.eventListeners.get(eventName).add(callback);
    }

    /**
     * Remove event listener
     * @param {string} eventName - Event name
     * @param {Function} callback - Event callback to remove
     */
    off(eventName, callback) {
        if (this.eventListeners.has(eventName)) {
            this.eventListeners.get(eventName).delete(callback);
        }
    }

    /**
     * Emit event
     * @param {string} eventName - Event name
     * @param {Object} data - Event data
     */
    emit(eventName, data = {}) {
        if (this.eventListeners.has(eventName)) {
            this.eventListeners.get(eventName).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Event handler error for ${eventName}:`, error);
                }
            });
        }
    }

    /**
     * Undo/Redo functionality
     */

    /**
     * Add operation to undo stack
     * @param {Object} operation - Operation to save
     * @private
     */
    addToUndoStack(operation) {
        this.undoStack.push({
            ...operation,
            timestamp: new Date().toISOString()
        });

        // Limit stack size
        if (this.undoStack.length > this.config.maxUndoSteps) {
            this.undoStack.shift();
        }
    }

    /**
     * Undo last operation
     * @returns {Promise<boolean>} True if undo successful
     */
    async undo() {
        if (this.undoStack.length === 0) {
            return false;
        }

        try {
            const operation = this.undoStack.pop();

            switch (operation.action) {
                case 'create':
                    // Remove the created task
                    await this.deleteTask(operation.taskId);
                    break;

                case 'toggle':
                    // Restore previous completion state
                    await this.state.updateTask(operation.taskId, {
                        completed: operation.previousState.completed
                    });
                    break;

                case 'update':
                    // Restore previous text
                    await this.state.updateTask(operation.taskId, {
                        text: operation.previousState.text
                    });
                    break;

                case 'delete':
                    // Restore the deleted task
                    const task = Task.fromJSON(operation.taskData);
                    this.state.addTask(task);
                    break;
            }

            // Add to redo stack
            this.redoStack.push(operation);

            // Emit events
            this.emit('undo:performed', operation);
            this.emit('state:changed');

            return true;
        } catch (error) {
            console.error('Failed to undo operation:', error);
            return false;
        }
    }

    /**
     * Redo last undone operation
     * @returns {Promise<boolean>} True if redo successful
     */
    async redo() {
        if (this.redoStack.length === 0) {
            return false;
        }

        try {
            const operation = this.redoStack.pop();

            // Re-execute the original operation
            switch (operation.action) {
                case 'create':
                    const task = Task.fromJSON(operation.taskData);
                    this.state.addTask(task);
                    break;

                case 'toggle':
                    await this.toggleTask(operation.taskId);
                    break;

                case 'update':
                    await this.updateTaskText(operation.taskId, operation.previousState.text);
                    break;

                case 'delete':
                    await this.deleteTask(operation.taskId);
                    break;
            }

            // Add back to undo stack
            this.undoStack.push(operation);

            // Emit events
            this.emit('redo:performed', operation);
            this.emit('state:changed');

            return true;
        } catch (error) {
            console.error('Failed to redo operation:', error);
            return false;
        }
    }

    /**
     * Utility methods
     */

    /**
     * Debounce function to limit frequent calls
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in milliseconds
     * @returns {Function} Debounced function
     * @private
     */
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    /**
     * Auto-save functionality
     * @private
     */
    autoSave() {
        if (!this.config.autoSave) {
            return;
        }

        // Clear existing timer
        if (this.autoSaveTimer) {
            clearTimeout(this.autoSaveTimer);
        }

        // Set new timer
        this.autoSaveTimer = setTimeout(async () => {
            try {
                const saved = await this.storage.saveState(this.state);
                if (saved) {
                    this.emit('autoSave:complete');
                }
            } catch (error) {
                console.error('Auto-save failed:', error);
                this.emit('autoSave:error', { error });
            }
        }, this.config.autoSaveDelay);
    }

    /**
     * Event handler implementations
     */

    /**
     * Handle task form submission
     * @private
     */
    handleAddTask() {
        const input = this.elements.taskInput;
        const text = input.value.trim();

        if (text) {
            this.addTask(text).then(taskId => {
                if (taskId) {
                    input.value = '';
                    input.focus();
                }
            });
        }
    }

    /**
     * Handle input change events
     * @private
     */
    handleInputChange() {
        // Could implement real-time validation or suggestions
        this.emit('input:changed', {
            value: this.elements.taskInput.value
        });
    }

    /**
     * Handle keyboard navigation
     * @param {KeyboardEvent} event - Keyboard event
     * @private
     */
    handleKeyboardNavigation(event) {
        // Ctrl/Cmd + Z for undo
        if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
            event.preventDefault();
            this.undo();
        }

        // Ctrl/Cmd + Shift + Z for redo
        if ((event.ctrlKey || event.metaKey) && event.key === 'z' && event.shiftKey) {
            event.preventDefault();
            this.redo();
        }

        // Ctrl/Cmd + Y for redo (alternative)
        if ((event.ctrlKey || event.metaKey) && event.key === 'y') {
            event.preventDefault();
            this.redo();
        }

        // Escape to cancel editing
        if (event.key === 'Escape') {
            this.cancelAllEditing();
        }
    }

    /**
     * Handle storage events for cross-tab synchronization
     * @param {StorageEvent} event - Storage event
     * @private
     */
    async handleStorageEvent(event) {
        if (event.key === this.storage.storageKey && event.newValue) {
            try {
                const newData = JSON.parse(event.newValue);
                const newState = new AppState();
                newState.fromJSON(newData.state);

                // Only update if different from current state
                if (JSON.stringify(this.state.toJSON()) !== JSON.stringify(newState.toJSON())) {
                    this.state = newState;
                    this.render();
                    this.emit('storage:sync');
                }
            } catch (error) {
                console.error('Failed to sync from storage event:', error);
            }
        }
    }

    /**
     * Handle storage errors
     * @param {CustomEvent} event - Storage error event
     * @private
     */
    handleStorageError(event) {
        console.error('Storage error:', event.detail.error);
        this.emit('storage:error', event.detail);
    }

    /**
     * Handle before unload event
     * @private
     */
    handleBeforeUnload() {
        // Force save any pending changes
        if (this.autoSaveTimer) {
            clearTimeout(this.autoSaveTimer);
            this.storage.saveState(this.state).catch(error => {
                console.error('Failed to save on unload:', error);
            });
        }
    }

    /**
     * Handle online/offline status changes
     * @param {boolean} isOnline - Online status
     * @private
     */
    handleOnlineStatus(isOnline) {
        this.emit('connection:changed', { isOnline });

        if (isOnline) {
            // Could implement cloud sync when coming back online
            this.emit('connection:restored');
        }
    }

    /**
     * Global error handler
     * @param {Error} error - Error to handle
     * @private
     */
    handleError(error) {
        console.error('Application error:', error);

        // Emit error event for UI feedback
        this.emit('app:error', {
            error: error.message,
            stack: error.stack
        });

        // Implement user-friendly error display
        this.showErrorToUser(error.message);
    }

    /**
     * Show error message to user
     * @param {string} message - Error message
     * @private
     */
    showErrorToUser(message) {
        // Create temporary error notification
        const notification = document.createElement('div');
        notification.className = 'error-notification';
        notification.textContent = `Error: ${message}`;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-width: 300px;
        `;

        document.body.appendChild(notification);

        // Remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    /**
     * Task editing methods
     */

    /**
     * Start editing a task
     * @param {string} taskId - Task ID to edit
     * @private
     */
    startEditTask(taskId) {
        const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
        if (!taskElement) return;

        const textSpan = taskElement.querySelector('.task-text');
        const editInput = taskElement.querySelector('.task-edit-input');

        if (textSpan && editInput) {
            // Hide text, show input
            textSpan.style.display = 'none';
            textSpan.setAttribute('contenteditable', 'false');

            editInput.style.display = 'block';
            editInput.value = textSpan.textContent;
            editInput.focus();
            editInput.select();

            // Mark as editing
            taskElement.classList.add('editing');

            this.emit('task:edit:start', { taskId });
        }
    }

    /**
     * Finish editing a task
     * @param {string} taskId - Task ID being edited
     * @private
     */
    finishEditTask(taskId) {
        const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
        if (!taskElement) return;

        const textSpan = taskElement.querySelector('.task-text');
        const editInput = taskElement.querySelector('.task-edit-input');

        if (textSpan && editInput) {
            const newText = editInput.value.trim();

            if (newText) {
                this.updateTaskText(taskId, newText).then(success => {
                    if (success) {
                        this.render(); // Re-render to show updated text
                    }
                });
            } else {
                // If empty text, cancel editing
                this.cancelEditTask(taskId);
            }
        }
    }

    /**
     * Cancel editing a task
     * @param {string} taskId - Task ID being edited
     * @private
     */
    cancelEditTask(taskId) {
        const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
        if (!taskElement) return;

        const textSpan = taskElement.querySelector('.task-text');
        const editInput = taskElement.querySelector('.task-edit-input');

        if (textSpan && editInput) {
            // Show text, hide input
            textSpan.style.display = 'block';
            editInput.style.display = 'none';

            // Remove editing state
            taskElement.classList.remove('editing');

            this.emit('task:edit:cancel', { taskId });
        }
    }

    /**
     * Cancel all active editing
     * @private
     */
    cancelAllEditing() {
        const editingElements = document.querySelectorAll('.task-item.editing');
        editingElements.forEach(element => {
            const taskId = element.dataset.taskId;
            this.cancelEditTask(taskId);
        });
    }
}

// Application initialization
let todoApp;

/**
 * Initialize the application when DOM is ready
 */
document.addEventListener('DOMContentLoaded', async () => {
    try {
        todoApp = new TodoApp();
        await todoApp.init();

        // Make app globally available for debugging
        window.todoApp = todoApp;

        console.log('Todo List application ready');
    } catch (error) {
        console.error('Failed to initialize application:', error);
    }
});

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { TodoApp, Task, AppState, StorageService, ValidationService };
}
```

## Acceptance Criteria

### Core Application Class ✅
- [ ] Implement TodoApp class with proper initialization
- [ ] Set up dependency injection system
- [ ] Create DOM element references and validation
- [ ] Implement comprehensive event listener system
- [ ] Add performance tracking and logging
- [ ] Include proper error handling and recovery

### Task Management Operations ✅
- [ ] Implement complete CRUD operations (Create, Read, Update, Delete)
- [ ] Add task toggling (complete/incomplete)
- [ ] Include task reordering functionality
- [ ] Implement task editing with inline editing mode
- [ ] Add input validation and sanitization
- [ ] Include undo/redo functionality with operation stacking

### UI Rendering System ✅
- [ ] Create efficient DOM rendering methods
- [ ] Implement progress bar with smooth animations
- [ ] Add task list rendering with proper sorting
- [ ] Include empty state management
- [ ] Implement responsive UI updates
- [ ] Add accessibility attributes and keyboard navigation

### Event System ✅
- [ ] Create comprehensive event system (on, off, emit)
- [ ] Implement event-driven architecture
- [ ] Add cross-tab synchronization via storage events
- [ ] Include keyboard shortcuts (undo/redo, navigation)
- [ ] Implement auto-save functionality with debouncing
- [ ] Add error event handling and user notification

### User Interaction Handling ✅
- [ ] Handle form submission for task creation
- [ ] Implement inline task editing
- [ ] Add keyboard navigation support
- [ ] Include drag-and-drop reordering (future enhancement)
- [ ] Implement proper focus management
- [ ] Add confirmation dialogs for destructive actions

### Performance Optimization ✅
- [ ] Implement debounced input handling
- [ ] Add efficient DOM manipulation techniques
- [ ] Include lazy loading strategies for large lists
- [ ] Implement render performance tracking
- [ ] Add memory management and cleanup
- [ ] Include proper event listener cleanup

### Error Handling & Recovery ✅
- [ ] Implement comprehensive error handling
- [ ] Add graceful degradation for storage failures
- [ ] Include user-friendly error notifications
- [ ] Implement data recovery mechanisms
- [ ] Add error logging and debugging support
- [ ] Include application health monitoring

### Cross-Browser Compatibility ✅
- [ ] Support for modern browsers (Chrome, Firefox, Safari, Edge)
- [ ] Graceful degradation for older browsers
- [ ] Include proper polyfills if needed
- [ ] Add feature detection for localStorage
- [ ] Implement consistent behavior across browsers

## Technical Specifications

### Architecture Pattern
- MVC (Model-View-Controller) inspired
- Event-driven architecture
- Component-based design
- Dependency injection pattern

### Performance Requirements
- Render time: < 50ms for 1000 tasks
- Operation response: < 100ms
- Memory usage: < 10MB with 1000 tasks
- Storage usage: < 1MB for 1000 tasks

### Browser Support
- Modern browsers (last 2 versions)
- ES6+ JavaScript support
- localStorage API support
- CSS3 feature support

### Accessibility Requirements
- WCAG 2.1 Level AA compliance
- Keyboard navigation support
- Screen reader compatibility
- ARIA attributes implementation
- Focus management

### Code Quality Standards
- ES6+ syntax and features
- Comprehensive error handling
- Performance monitoring
- Code documentation and comments
- Maintainable and extensible structure

## Dependencies
- **Epic**: todo-list
- **Task**: 2 (Project Setup & HTML Structure)
- **Task**: 4 (Data Layer & localStorage) - for data models

## Blocked By
- Task 2: Project Setup & HTML Structure

## Blocks
- Task 5: User Interface Integration
- Task 7: Testing & Quality Assurance

## Notes
- This architecture provides a solid foundation for the todo list application
- Built with scalability and maintainability in mind
- Ready for future enhancements like cloud sync, advanced filtering, and analytics
- Comprehensive error handling ensures reliability
- Performance optimized for large datasets
